module Internal =

    abstract class Vector<T>(size) =
        abstract Sparse: bool
        abstact Index: ISortedSet<int>
        Get: int -> T
        Size: int
        abstract Add(Vector<T>) -> Vector<T>
        abstract Sub(Vector<T>) -> Vector<T>
        abstract Cross(Vector<T>) -> Vector<T>
        abstract Dot(Vector<T>r) -> Vector<T>

    abstract class VectorBuffer<T>(size): Vector<T> =
        public abstract Set: int * T -> unit
        override Add, Sub, Cross, Dot

    class DenseVector<T>(size): VectorBuffer<T>
        override Sparse, Index

    class SparseVector<T>(size): VectorBuffer<T>
        override Sparse, Index

    abstract class Matrix<T>(Rows, Columns) =
        abstract Sparse: bool
        abstract Index: ISortedSet<int>
        Get: int -> Vector<T>
        Rows: int
        Columns: int
        abstract Add: Matrix<T> -> Matrix<T>
        abstract Sub: Matrix<T> -> Matrix<T>
        abstract Multiply: Matrix<T> -> Matrix<T>
        abstract Invert: unit -> Matrix<T>
        abstract Transpore: unit -> Matrix<T>

    abstract class MatrixBuffer<T>(rows, column): Matrix<T> =
        public abstract Set: int * int * T -> unit
        override Add, Sub, Multiply

    class DenseMatrix<T>(rows, column, int * int -> T): MatrixBuffer<T>
        override Sparse, Index, Transpose, Invert

    class SparseMatrix<T>(rows, column, IEnumerable<int, int, T>): MatrixBuffer<T>
        override Sparse, Index, Transpose, Invert


class Vector<T> private (data: Internal.VectorBuffer<T>)
    private Data: Internal.Vector<T> = data
    Get: int -> T
    Size: int
    static *
    static .*
    static -
    static +
    static Dense
    static Sparse

class Matrix<T> private (data: Internal.MatrixBuffer<T>)
    private Data: Internal.Matrix<T> = data
    Rows: int
    Columns: int
    Sparse: bool
    Row: int -> int -> T
    Column: int -> int -> T
    Invert: unit -> Matrix<T>
    Transpose: unit -> Matrix<T>
    static *
    static -
    static +
    static Dense
    static Sparse

____________________________________________________________________________________

let rec CrawlUnion (b1: Enumerator) (b2: Enumerator) Action =
    if (b1 or b2) then
        if b1.Value > b2.Value then
            Action b1.Value b2.Value
            CrawlUnion b1 (b2.MoveNext())
        else if b1.Value < b2.Value then
            Action b1.Value b2.Value
            CrawlUnion (b1.MoveNext()) b2
        else
            assert (b1.Value == b2.Value)
            CrawlUnion (b1.MoveNext()) (b2.MoveNext())

let rec CrawlInteraction (b1: Enumerator) (b2: Enumerator) Action =
    if (b1 and b2) then
        if b1.Value > b2.Value then
            CrawlInteraction b1 (b2.MoveNext())
        else if b1.Value < b2.Value then
            CrawlInteraction (b1.MoveNext()) b2
        else
            assert (b1.Value == b2.Value)
            Action b1.Value
            CrawlInteraction (b1.MoveNext()) (b2.MoveNext())
____________________________________________________________________________________

M.Get(i, j) -> O(log N)
M.Set(i, j) -> O(log N)

class ArrayOfMap:
    Get: O(log K)
    Set: O(log K)

fun Swap(i, j, Row: ArrayOfMap, Column: ArrayOfMap, Result): unit = // O(K . log K)
    for j in Row[i]:
        c = Row.Get(i, j)
        Row.Set( i, j, Row.Get(i, k)) // O(log k)
        Row.Set( i, k, c) // O(log k)

fun ColumnMax(i): int = // O(K)

fun Invert(M) =
    let Row = ArrayOfMap(N)
    let Column = ArrayOfMap(N)
    let Result = ArrayOfMap(N)

    for i in 1 .. N do
        Result(i, i) = 1

    for i in 1 .. N do // O(N . K . log K)
        def V = M.Row[i] // O(log N)
        def Keys = V.KeySet(i)

        for j in V do O(K . log K)
            c = V.Key[j]
            Row[i].Add(c, V.Value[j])  // O(log K)
            Column[i].Add(c, V.Value[j])  // O(log K)

    for i in 1 .. N do // O(N . K . K)

        if Row.Get(i, i) = 0 then
            k = ColumnMax(i)
            if Row.Get(i, k) = 0 then return

            Swap(i, k)
            Swap(k, i)

        for k in Column[i] do O(K . K)
            Eliminate(Row, Column, Result, i, k) // O(K)

        assert (Row.Get(i, i) > 0)
        assert (Column.Get(i, i) > 0)

    for i in 1 .. N do // O(N . K . K)
        k = Row.Get(i, i)
        for j in Result.Row(i)
            Result[i][j] /= k

    return Result
