interface Vector<T> =
    internal Sparse: bool
    internal Index: ISortedSet<T>
    virtual []: int -> T with get
    Size: int
    // Exists: int -> bool
    static *
    static .*
    static -
    static +

Module Vector =

    interface Vector.Buffer<T> =
        virtual []: int -> T with get & set
        void Overwrite(Vector<T>)

    private fun Dot (v1: Vector<T>) (v2: Vector<T>) -> T
    private fun Op (v1: Vector<T>) (v2: Vector<T>)
                   (f: T * T -> T) : Vector.Buffer<T>

    private DenseBuffer<T>(length): Vector.Buffer<T>
    private SparseBuffer<T>(length): Vector.Buffer<T>

    module Sparse =
        fun Buffer(length: int): Vector.Buffer<T>

    fun Dense(length: int, gen: int -> T): Vector<T>

    module Dense =
        fun Buffer(lenght: int, gen: int -> T): Vector.Buffer<T>

____________________________________________________________________________________

interface Matrix<T> =
    internal Sparse: bool
    internal Index: ISortedSet<T>
    Rows: int
    Columns: int
    Row: int -> T
    Column: int -> T
    Invert: unit -> Matrix<T>
    Transpose: unit -> Matrix<T>
    // Exists: int * int -> bool
    virtual []: int * int -> T with public get
    static *
    static -
    static +

module Matrix =

    interface Matrix.Buffer<T> =
        virtual []: int * int -> T with public get and set
        void Overwrite(Matrix<T>)

    private fun Mult (m1: Matrix<T>) (m2: Matrix<T>)
    private fun Op (m1: Matrix<T>) (m2: Matrix<T>)
                   (f: T * T -> T): Matrix.Buffer<T>

    private DenseBuffer<T>(rows, columns): Matrix.Buffer<T>
        internal Rows: int
        internal Columns: int
        internal Get(int, int) -> T
        internal Transport: unit -> Matrix.Buffer<T>
        internal Invert: unit -> Matrix.Buffer<T>
        operator[]: int -> Vector.Buffer<T> with get , set

    private SparseBuffer<T>(rows, columns): Matrix.Buffer<T>
        internal Rows: int
        internal Columns: int
        internal Get(int, int) -> T
        internal Transport: unit -> Matrix.Buffer<T>
        internal Invert: unit -> Matrix.Buffer<T>
        operator[]: int -> Vector.Buffer<T> with get , set

    public fun Sparse(length: int): Matrix.Buffer<T>

    module Sparse =
        public fun Identity(length): Matrix.Buffer<T>
        publin fun Buffer(rows, columns): Matrix.Buffer<T>

    public fun Dense(length: int, gen: (int * int) -> T): Matrix<T>

    module Dense =
        module Buffer =
            public fun Identity(length): Matrix.Buffer<T>
        public fun Identity(length): Matrix<T>
        public fun Buffer(length: int, gen: (int * int) -> T): Matrix.Buffer<T>

____________________________________________________________________________________

let rec CrawlUnion (b1: Enumerator) (b2: Enumerator) Action =
    if (b1 or b2) then
        if b1.Value > b2.Value then
            Action b1.Value b2.Value
            CrawlUnion b1 (b2.MoveNext())
        else if b1.Value < b2.Value then
            Action b1.Value b2.Value
            CrawlUnion (b1.MoveNext()) b2
        else
            assert (b1.Value == b2.Value)
            CrawlUnion (b1.MoveNext()) (b2.MoveNext())

let rec CrawlInteraction (b1: Enumerator) (b2: Enumerator) Action =
    if (b1 and b2) then
        if b1.Value > b2.Value then
            CrawlInteraction b1 (b2.MoveNext())
        else if b1.Value < b2.Value then
            CrawlInteraction (b1.MoveNext()) b2
        else
            assert (b1.Value == b2.Value)
            Action b1.Value
            CrawlInteraction (b1.MoveNext()) (b2.MoveNext())
