abstract class Vector<T>(size) =
    protected abstract Sparse: bool
    protected abstract Index: ISortedSet<T>
    protected abstract Get: int -> T
    protected abstract Set: int * T -> unit
    virtual []: int -> T with get
    Size: int
    static *
    static .*
    static -
    static +

and abstract class VectorBuffer(size): Vector<T> =
    virtual []: int -> T with get & set
    void Overwrite(Vector<T>)

____________________________________________________________________________________

abstract class Matrix<T>(rows, columns) =
    protected abstract Sparse: bool
    protected abstract Index: ISortedSet<T>
    protected abstract Get: int * int -> T
    protected abstract Set: int * int * T -> unit
    protected abstract Update: int * VectorBuffer<T> -> unit
    Rows: int
    Columns: int
    Row: int -> T
    Column: int -> T
    public abstract Invert: unit -> Matrix<T>
    public abstract Transpose: unit -> Matrix<T>
    public virtual []: int * int -> T with public get
    protected static Multiply: MatrixBuffer<T>
    protected static Add, Sub: MatrixBuffer<T>
    static *
    static -
    static +

and abstract class MatrixBuffer<T>: Matrix<T> =
    virtual []: int * int -> T with public get and set
    void Overwrite(Matrix<T>)
    static *
    static -
    static +

____________________________________________________________________________________

module Design =

    private DenseVectorBuffer<T>(rows, columns): VectorBuffer<T>
    private DenseMatrixBuffer<T>(rows, columns): MatrixBuffer<T>
    let Vector(size, gen): Vector(T) = DenseVectorBuffer<T>(size, gen)
    let VectorBuffer(length): VectorBuffer(T) = DenseVectorBuffer<T>(size)
    let Matrix: Matrix(T) = DenseBuffer<T>(rows, columns, gen)
    let MatrixBuffer: MatrixBuffer(T) = DenseBuffer<T>(rows, columns)
    let identity (i, j) =
    let IdentityBuffer(length) =

module Sparse =

    private DenseVectorBuffer<T>(rows, columns): VectorBuffer<T>
    private DenseMatrixBuffer<T>(rows, columns): MatrixBuffer<T>
    let Vector(size, gen): Vector(T) = DenseVectorBuffer<T>(size, gen)
    let VectorBuffer(length): VectorBuffer(T) = DenseVectorBuffer<T>(size)
    let Matrix: Matrix(T) = DenseBuffer<T>(rows, columns, gen)
    let MatrixBuffer: MatrixBuffer(T) = DenseBuffer<T>(rows, columns)
    let identity (i, j) =
    let IdentityBuffer(length) =

____________________________________________________________________________________

let rec CrawlUnion (b1: Enumerator) (b2: Enumerator) Action =
    if (b1 or b2) then
        if b1.Value > b2.Value then
            Action b1.Value b2.Value
            CrawlUnion b1 (b2.MoveNext())
        else if b1.Value < b2.Value then
            Action b1.Value b2.Value
            CrawlUnion (b1.MoveNext()) b2
        else
            assert (b1.Value == b2.Value)
            CrawlUnion (b1.MoveNext()) (b2.MoveNext())

let rec CrawlInteraction (b1: Enumerator) (b2: Enumerator) Action =
    if (b1 and b2) then
        if b1.Value > b2.Value then
            CrawlInteraction b1 (b2.MoveNext())
        else if b1.Value < b2.Value then
            CrawlInteraction (b1.MoveNext()) b2
        else
            assert (b1.Value == b2.Value)
            Action b1.Value
            CrawlInteraction (b1.MoveNext()) (b2.MoveNext())
