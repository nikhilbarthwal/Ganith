abstract class Vector<T>(size) =
    protected abstract Sparse: bool
    protected abstract Index: ISortedSet<T>
    protected abstract Get: int -> T
    protected abstract Set: int * T -> unit
    virtual []: int -> T with get
    Size: int
    static *
    static .*
    static -
    static +

and abstract class VectorBuffer(size): Vector<T> =
    virtual []: int -> T with get & set
    void Overwrite(Vector<T>)

____________________________________________________________________________________

abstract class Matrix<T>(rows, columns) =
    protected abstract Sparse: bool
    protected abstract Index: ISortedSet<T>
    protected abstract Get: int * int -> T
    protected abstract Set: int * int * T -> unit
    protected abstract Update: int * VectorBuffer<T> -> unit
    Rows: int
    Columns: int
    Row: int -> T
    Column: int -> T
    public abstract Invert: unit -> Matrix<T>
    public abstract Transpose: unit -> Matrix<T>
    public virtual []: int * int -> T with public get
    protected static Multiply: MatrixBuffer<T>
    protected static Add, Sub: MatrixBuffer<T>
    static *
    static -
    static +

and abstract class MatrixBuffer<T>: Matrix<T> =
    virtual []: int * int -> T with public get and set
    void Overwrite(Matrix<T>)
    static *
    static -
    static +

____________________________________________________________________________________

module Design =

    private DenseVectorBuffer<T>(rows, columns): VectorBuffer<T>
    private DenseMatrixBuffer<T>(rows, columns): MatrixBuffer<T>
    let Vector(size, gen): Vector(T) = DenseVectorBuffer<T>(size, gen)
    let VectorBuffer(length): VectorBuffer(T) = DenseVectorBuffer<T>(size)
    let Matrix: Matrix(T) = DenseBuffer<T>(rows, columns, gen)
    let MatrixBuffer: MatrixBuffer(T) = DenseBuffer<T>(rows, columns)
    let identity (i, j) =
    let IdentityBuffer(length) =

module Sparse =

    private DenseVectorBuffer<T>(rows, columns): VectorBuffer<T>
    private DenseMatrixBuffer<T>(rows, columns): MatrixBuffer<T>
    let Vector(size, gen): Vector(T) = DenseVectorBuffer<T>(size, gen)
    let VectorBuffer(length): VectorBuffer(T) = DenseVectorBuffer<T>(size)
    let Matrix: Matrix(T) = DenseBuffer<T>(rows, columns, gen)
    let MatrixBuffer: MatrixBuffer(T) = DenseBuffer<T>(rows, columns)
    let identity (i, j) =
    let IdentityBuffer(length) =

____________________________________________________________________________________

let rec CrawlUnion (b1: Enumerator) (b2: Enumerator) Action =
    if (b1 or b2) then
        if b1.Value > b2.Value then
            Action b1.Value b2.Value
            CrawlUnion b1 (b2.MoveNext())
        else if b1.Value < b2.Value then
            Action b1.Value b2.Value
            CrawlUnion (b1.MoveNext()) b2
        else
            assert (b1.Value == b2.Value)
            CrawlUnion (b1.MoveNext()) (b2.MoveNext())

let rec CrawlInteraction (b1: Enumerator) (b2: Enumerator) Action =
    if (b1 and b2) then
        if b1.Value > b2.Value then
            CrawlInteraction b1 (b2.MoveNext())
        else if b1.Value < b2.Value then
            CrawlInteraction (b1.MoveNext()) b2
        else
            assert (b1.Value == b2.Value)
            Action b1.Value
            CrawlInteraction (b1.MoveNext()) (b2.MoveNext())
____________________________________________________________________________________

M.Get(i, j) -> O(log N)
M.Set(i, j) -> O(log N)

class ArrayOfMap:
    Get: O(log K)
    Set: O(log K)

fun Swap(i, j, Row: ArrayOfMap, Column: ArrayOfMap, Result): unit = // O(K . log K)
    for j in Row[i]:
        c = Row.Get(i, j)
        Row.Set( i, j, Row.Get(i, k)) // O(log k)
        Row.Set( i, k, c) // O(log k)

fun ColumnMax(i): int = // O(K)

fun Invert(M) =
    let Row = ArrayOfMap(N)
    let Column = ArrayOfMap(N)
    let Result = ArrayOfMap(N)

    for i in 1 .. N do
        Result(i, i) = 1

    for i in 1 .. N do // O(N . K . log K)
        def V = M.Row[i] // O(log N)
        def Keys = V.KeySet(i)

        for j in V do O(K . log K)
            c = V.Key[j]
            Row[i].Add(c, V.Value[j])  // O(log K)
            Column[i].Add(c, V.Value[j])  // O(log K)

    for i in 1 .. N do // O(N . K . K)

        if Row.Get(i, i) = 0 then
            k = ColumnMax(i)
            if Row.Get(i, k) = 0 then return

            Swap(i, k)
            Swap(k, i)

        for k in Column[i] do O(K . K)
            Eliminate(Row, Column, Result, i, k) // O(K)

        assert (Row.Get(i, i) > 0)
        assert (Column.Get(i, i) > 0)

    for i in 1 .. N do // O(N . K . K)
        k = Row.Get(i, i)
        for j in Result.Row(i)
            Result[i][j] /= k

    return Result
